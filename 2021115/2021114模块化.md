### 模块化
#### 如果不用模块化编写代码，会有以下问题：
    1. 代码杂乱无章，没有条理性，不便于维护，不便于复用
    2. 全局变量污染
    3. 不方便保护私有数据（闭包实现私有化数据）

#### 模块化的基本实现：闭包的自调用函数
   --- js
        // 日期控件
        var DatePicker = (function() {
          return {
            init() {}
          }
        }){}

### AMD模块化  --- 指向requireJS    
   1. AMD async module define 异步模块定义
   2. AMD其实就是requireJS实现的模块化解决方案

### 其他模块化解决方案
   1. CommonJS： node中使用的模块化解决方案
   2. CMD (common module define): seajs中提出来的
     模块化解决方案
        a. 其实CMD可以认为是CommonJS的前端实现
        b. seajs由阿里(玉帛)的编写
        c. seajs 最近比较火，在16年停止更新

### AMD与CMD的不同之处
   1. amd需要依赖前置 cmd需要依赖就近
   2. 导入导出方式不同
      amd通过define定义，return导出
      cmd不需要定义 只需要最后通过module.exports
      和exports导出

### requireJS --- AMD规范
#### 中文网 `https://www.html.cn/doc/requirejs/`
#### 基本用法  
    --js
      //1. 通过script导入requirejs源文件
      //2. 编写模板文件，基本格式如下 
      ## 在一个单页面应用中，只需要调用一次require，后面全是
         define， []里写调用文件的路径如['***','---'] 
      index.html 文件  
      <script src='require.js'></script>
      <script>
        require(['cart'], function(){
          首页模块自己的逻辑
        })
      </script>

      // cart.js文件
      define([],function(){
        ....子模块cart的逻辑
      })

     ## 实现点击按钮实现加载用户模块，（按需加载）
       index.html
          <bytton id="button">按需加载</button>
          <script src='require.js'></script>
          <script>
             // 给回调函数添加形参，接收前面对应模块的返回值，模块返回什么，形参的值就是什么
             // 形参顺序，必须和前面调用模块的顺序保存一致
            require(['user'], function(user){ 
              var btn = document.getElementById('button');
              btn.onclick= function(){
                // 调用用户逻辑
                user();
              }
            })
          </script>

       user.js
          define([],function(){
            return function() {
              console.log('user逻辑');
            }
          })  

  注意：分不清什么时候用按需加载什么时候用立即执行，都用按需加载 （逻辑上的按需加载，不是字面量上的按需加载）

#### requireJS入口文件
     可以把之前写的require([],function(){}) 封装到外部js文件中
     ##  引入外部文件的方法
      1)  直接一个一个引入js文件
      2)  使用data-main属性
          <script data-main='./**.js' src="require.js"></script>
      注意：此处data-main不是自定义属性，而是引入文件

#### requireJS 入口文件的配置
     require.config({
       // baseUrl
       // paths: objetc : 用来配置一些常用的文件、文件夹路径
       paths: {
         // 日后使用名称:  文件路径
         jquery: '路径'
       }
       // shim
     })

######　开发中使用JQ的话，requireJS文件的每个模块都需引入
   mian.js 文件
      require(['jquery.js'], function($){})
   user.js 文件
     define(['jquery.js'], function($){})
     1. 为什么要每个模块都引入jQ呢？
        --- 为了防止全局变量污染：$    
             --> zepto 中有$属性
        --- 使用amd的方法每一个模块导入一下，$就是一个局部变量

      2. 我们要使用paths来配置jquery 为什么
         a.如果jquery版本变了，这需要所有的引用都改变
         b. 如果jquery文件地址换了，这是需要全部还地址

      3 注意：在define([],function) 或者 require([],function(){}) 写文件地址的时候是以require所在的js文件所在目录进行查找的

### 检查第三方库是否支持AMD规范
    看源码中是否有下面代码
       if(typeof define === 'function' && define.amd) {
         define([], function(){
           return jQuery;
         });
       }      